<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ADNLPModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ADNLPModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../backend/">Backend</a></li><li><a class="tocitem" href="../predefined/">Default backends</a></li><li><a class="tocitem" href="../mixed/">Build a hybrid NLPModel</a></li><li><a class="tocitem" href="../generic/">Support multiple precision</a></li><li><a class="tocitem" href="../sparse/">Sparse Jacobian and Hessian</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ADNLPModels.ADModelBackend"><code>ADNLPModels.ADModelBackend</code></a></li><li><a href="#ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S"><code>ADNLPModels.ADNLPModel</code></a></li><li><a href="#ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S"><code>ADNLPModels.ADNLSModel</code></a></li><li><a href="#ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}"><code>ADNLPModels.compute_hessian_sparsity</code></a></li><li><a href="#ADNLPModels.compute_jacobian_sparsity"><code>ADNLPModels.compute_jacobian_sparsity</code></a></li><li><a href="#ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}"><code>ADNLPModels.get_F</code></a></li><li><a href="#ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_adbackend</code></a></li><li><a href="#ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_c</code></a></li><li><a href="#ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}"><code>ADNLPModels.get_default_backend</code></a></li><li><a href="#ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}"><code>ADNLPModels.get_lag</code></a></li><li><a href="#ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_nln_nnzh</code></a></li><li><a href="#ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_nln_nnzj</code></a></li><li><a href="#ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_residual_nnzj</code></a></li><li><a href="#ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}"><code>ADNLPModels.set_adbackend!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.ADModelBackend" href="#ADNLPModels.ADModelBackend"><code>ADNLPModels.ADModelBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ADModelBackend(gradient_backend, hprod_backend, jprod_backend, jtprod_backend, jacobian_backend, hessian_backend, ghjvprod_backend, hprod_residual_backend, jprod_residual_backend, jtprod_residual_backend, jacobian_residual_backend, hessian_residual_backend)</code></pre><p>Structure that define the different backend used to compute automatic differentiation of an <code>ADNLPModel</code>/<code>ADNLSModel</code> model. The different backend are all subtype of <code>ADBackend</code> and are respectively used for:</p><ul><li>gradient computation;</li><li>hessian-vector products;</li><li>jacobian-vector products;</li><li>transpose jacobian-vector products;</li><li>jacobian computation;</li><li>hessian computation;</li><li>directional second derivative computation, i.e. gᵀ ∇²cᵢ(x) v.</li></ul><p>The default constructors are      ADModelBackend(nvar, f, ncon = 0, c = (args...) -&gt; []; show<em>time::Bool = false, kwargs...)     ADModelNLSBackend(nvar, F!, nequ, ncon = 0, c = (args...) -&gt; []; show</em>time::Bool = false, kwargs...)</p><p>If <code>show_time</code> is set to <code>true</code>, it prints the time used to generate each backend.</p><p>The remaining <code>kwargs</code> are either the different backends as listed below or arguments passed to the backend&#39;s constructors:</p><ul><li><code>gradient_backend = ForwardDiffADGradient</code>;</li><li><code>hprod_backend = ForwardDiffADHvprod</code>;</li><li><code>jprod_backend = ForwardDiffADJprod</code>;</li><li><code>jtprod_backend = ForwardDiffADJtprod</code>;</li><li><code>jacobian_backend = SparseADJacobian</code>;</li><li><code>hessian_backend = ForwardDiffADHessian</code>;</li><li><code>ghjvprod_backend = ForwardDiffADGHjvprod</code>;</li><li><code>hprod_residual_backend = ForwardDiffADHvprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jprod_residual_backend = ForwardDiffADJprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jtprod_residual_backend = ForwardDiffADJtprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jacobian_residual_backend = SparseADJacobian</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>hessian_residual_backend = ForwardDiffADHessian</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ad.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S" href="#ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S"><code>ADNLPModels.ADNLPModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ADNLPModel(f, x0)
ADNLPModel(f, x0, lvar, uvar)
ADNLPModel(f, x0, clinrows, clincols, clinvals, lcon, ucon)
ADNLPModel(f, x0, A, lcon, ucon)
ADNLPModel(f, x0, c, lcon, ucon)
ADNLPModel(f, x0, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLPModel(f, x0, A, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, c, lcon, ucon)
ADNLPModel(model::AbstractNLPModel)</code></pre><p>ADNLPModel is an AbstractNLPModel using automatic differentiation to compute the derivatives. The problem is defined as</p><pre><code class="nohighlight hljs"> min  f(x)
s.to  lcon ≤ (  Ax  ) ≤ ucon
             ( c(x) )
      lvar ≤   x  ≤ uvar.</code></pre><p>The following keyword arguments are available to all constructors:</p><ul><li><code>minimize</code>: A boolean indicating whether this is a minimization problem (default: true)</li><li><code>name</code>: The name of the model (default: &quot;Generic&quot;)</li></ul><p>The following keyword arguments are available to the constructors for constrained problems:</p><ul><li><code>y0</code>: An inital estimate to the Lagrangian multipliers (default: zeros)</li></ul><p><code>ADNLPModel</code> uses <code>ForwardDiff</code> and <code>ReverseDiff</code> for the automatic differentiation. One can specify a new backend with the keyword arguments <code>backend::ADNLPModels.ADBackend</code>. There are three pre-coded backends:</p><ul><li>the default <code>ForwardDiffAD</code>.</li><li><code>ReverseDiffAD</code>.</li><li><code>ZygoteDiffAD</code> accessible after loading <code>Zygote.jl</code> in your environment.</li></ul><p>For an advanced usage, one can define its own backend and redefine the API as done in <a href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/src/forward.jl">ADNLPModels.jl/src/forward.jl</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
nvar = 3
ADNLPModel(f, x0) # uses the default ForwardDiffAD backend.
ADNLPModel(f, x0; backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLPModel(f, x0; backend = ADNLPModels.ZygoteAD)</code></pre><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
c(x) = [1x[1] + x[2]; x[2]]
nvar, ncon = 3, 2
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ZygoteAD)</code></pre><p>For in-place constraints function, use one of the following constructors:</p><pre><code class="nohighlight hljs">ADNLPModel!(f, x0, c!, lcon, ucon)
ADNLPModel!(f, x0, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLPModel!(f, x0, A, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, c!, lcon, ucon)
ADNLSModel!(model::AbstractNLSModel)</code></pre><p>where the constraint function has the signature <code>c!(output, input)</code>.</p><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
function c!(output, x) 
  output[1] = 1x[1] + x[2]
  output[2] = x[2]
end
nvar, ncon = 3, 2
nlp = ADNLPModel!(f, x0, c!, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/nlp.jl#L29-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S" href="#ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S"><code>ADNLPModels.ADNLSModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ADNLSModel(F, x0, nequ)
ADNLSModel(F, x0, nequ, lvar, uvar)
ADNLSModel(F, x0, nequ, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel(F, x0, nequ, A, lcon, ucon)
ADNLSModel(F, x0, nequ, c, lcon, ucon)
ADNLSModel(F, x0, nequ, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLSModel(F, x0, nequ, A, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, A, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, A, c, lcon, ucon)
ADNLSModel(model::AbstractNLSModel)</code></pre><p>ADNLSModel is an Nonlinear Least Squares model using automatic differentiation to compute the derivatives. The problem is defined as</p><pre><code class="nohighlight hljs"> min  ½‖F(x)‖²
s.to  lcon ≤ (  Ax  ) ≤ ucon
             ( c(x) )
      lvar ≤   x  ≤ uvar</code></pre><p>where <code>nequ</code> is the size of the vector <code>F(x)</code> and the linear constraints come first.</p><p>The following keyword arguments are available to all constructors:</p><ul><li><code>linequ</code>: An array of indexes of the linear equations (default: <code>Int[]</code>)</li><li><code>minimize</code>: A boolean indicating whether this is a minimization problem (default: true)</li><li><code>name</code>: The name of the model (default: &quot;Generic&quot;)</li></ul><p>The following keyword arguments are available to the constructors for constrained problems:</p><ul><li><code>y0</code>: An inital estimate to the Lagrangian multipliers (default: zeros)</li></ul><p><code>ADNLSModel</code> uses <code>ForwardDiff</code> and <code>ReverseDiff</code> for the automatic differentiation. One can specify a new backend with the keyword arguments <code>backend::ADNLPModels.ADBackend</code>. There are three pre-coded backends:</p><ul><li>the default <code>ForwardDiffAD</code>.</li><li><code>ReverseDiffAD</code>.</li><li><code>ZygoteDiffAD</code> accessible after loading <code>Zygote.jl</code> in your environment.</li></ul><p>For an advanced usage, one can define its own backend and redefine the API as done in <a href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/src/forward.jl">ADNLPModels.jl/src/forward.jl</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels
F(x) = [x[2]; x[1]]
nequ = 2
x0 = ones(3)
nvar = 3
ADNLSModel(F, x0, nequ) # uses the default ForwardDiffAD backend.
ADNLSModel(F, x0, nequ; backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLSModel(F, x0, nequ; backend = ADNLPModels.ZygoteAD)</code></pre><pre><code class="language-julia hljs">using ADNLPModels
F(x) = [x[2]; x[1]]
nequ = 2
x0 = ones(3)
c(x) = [1x[1] + x[2]; x[2]]
nvar, ncon = 3, 2
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ZygoteAD)</code></pre><p>For in-place constraints and residual function, use one of the following constructors:</p><pre><code class="nohighlight hljs">ADNLSModel!(F!, x0, nequ)
ADNLSModel!(F!, x0, nequ, lvar, uvar)
ADNLSModel!(F!, x0, nequ, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel!(F!, x0, nequ, A, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, A, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, A, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, A, clcon, ucon)
ADNLSModel!(model::AbstractNLSModel)</code></pre><p>where the constraint function has the signature <code>c!(output, input)</code>.</p><pre><code class="language-julia hljs">using ADNLPModels
function F!(output, x)
  output[1] = x[2]
  output[2] = x[1]
end
nequ = 2
x0 = ones(3)
function c!(output, x) 
  output[1] = 1x[1] + x[2]
  output[2] = x[2]
end
nvar, ncon = 3, 2
nls = ADNLSModel!(F!, x0, nequ, c!, zeros(ncon), zeros(ncon))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/nls.jl#L33-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}" href="#ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}"><code>ADNLPModels.compute_hessian_sparsity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_hessian_sparsity(f, nvar, c!, ncon; detector)</code></pre><p>Return a sparse boolean matrix that represents the adjacency matrix of the Hessian of f(x) + λᵀc(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/sparsity_pattern.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.compute_jacobian_sparsity" href="#ADNLPModels.compute_jacobian_sparsity"><code>ADNLPModels.compute_jacobian_sparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_jacobian_sparsity(c, x0; detector)
compute_jacobian_sparsity(c!, cx, x0; detector)</code></pre><p>Return a sparse boolean matrix that represents the adjacency matrix of the Jacobian of c(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/sparsity_pattern.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}" href="#ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}"><code>ADNLPModels.get_F</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_F(nls)
get_F(nls, ::ADBackend)</code></pre><p>Return the out-of-place version of <code>nls.F!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ADNLPModels.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}" href="#ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_adbackend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_adbackend(nlp)</code></pre><p>Returns the value <code>adbackend</code> from nlp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ADNLPModels.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}" href="#ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_c(nlp)
get_c(nlp, ::ADBackend)</code></pre><p>Return the out-of-place version of <code>nlp.c!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ADNLPModels.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}" href="#ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}"><code>ADNLPModels.get_default_backend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_default_backend(meth::Symbol, backend::Symbol; kwargs...)
get_default_backend(::Val{::Symbol}, backend; kwargs...)</code></pre><p>Return a type <code>&lt;:ADBackend</code> that corresponds to the default <code>backend</code> use for the method <code>meth</code>. See <code>keys(ADNLPModels.predefined_backend)</code> for a list of possible backends.</p><p>The following keyword arguments are accepted:</p><ul><li><code>matrix_free::Bool</code>: If <code>true</code>, this returns an <code>EmptyADbackend</code> for methods that handle matrices, e.g. <code>:hessian_backend</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/predefined_backend.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}" href="#ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}"><code>ADNLPModels.get_lag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_lag(nlp, b::ADBackend, obj_weight)
get_lag(nlp, b::ADBackend, obj_weight, y)</code></pre><p>Return the lagrangian function <code>ℓ(x) = obj_weight * f(x) + c(x)ᵀy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ADNLPModels.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}" href="#ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_nln_nnzh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nln_nnzh(::ADBackend, nvar)
get_nln_nnzh(b::ADModelBackend, nvar)
get_nln_nnzh(nlp::AbstractNLPModel, nvar)</code></pre><p>For a given <code>ADBackend</code> of a problem with <code>nvar</code> variables, return the number of nonzeros in the lower triangle of the Hessian. If <code>b</code> is the <code>ADModelBackend</code> then <code>b.hessian_backend</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ad_api.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}" href="#ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_nln_nnzj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_nln_nnzj(::ADBackend, nvar, ncon)
get_nln_nnzj(b::ADModelBackend, nvar, ncon)
get_nln_nnzj(nlp::AbstractNLPModel, nvar, ncon)</code></pre><p>For a given <code>ADBackend</code> of a problem with <code>nvar</code> variables and <code>ncon</code> constraints, return the number of nonzeros in the Jacobian of nonlinear constraints. If <code>b</code> is the <code>ADModelBackend</code> then <code>b.jacobian_backend</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ad_api.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}" href="#ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_residual_nnzj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_residual_nnzj(b::ADModelBackend, nvar, nequ)</code></pre><p>Return <code>get_nln_nnzj(b.jacobian_residual_backend, nvar, nequ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ad_api.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}" href="#ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}"><code>ADNLPModels.set_adbackend!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_adbackend!(nlp, new_adbackend)
set_adbackend!(nlp; kwargs...)</code></pre><p>Replace the current <code>adbackend</code> value of nlp by <code>new_adbackend</code> or instantiate a new one with <code>kwargs</code>, see <code>ADModelBackend</code>. By default, the setter with kwargs will reuse existing backends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/c1b09196ec9e686c9f3efa3c56d1803bb883aeb3/src/ADNLPModels.jl#L246-L252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Performance tips</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 18 June 2024 04:57">Tuesday 18 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
