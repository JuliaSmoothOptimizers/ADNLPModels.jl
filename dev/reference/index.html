<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ADNLPModels.jl</title><meta name="title" content="Reference · ADNLPModels.jl"/><meta property="og:title" content="Reference · ADNLPModels.jl"/><meta property="twitter:title" content="Reference · ADNLPModels.jl"/><meta name="description" content="Documentation for ADNLPModels.jl."/><meta property="og:description" content="Documentation for ADNLPModels.jl."/><meta property="twitter:description" content="Documentation for ADNLPModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ADNLPModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ADNLPModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../backend/">Backend</a></li><li><a class="tocitem" href="../predefined/">Default backends</a></li><li><a class="tocitem" href="../mixed/">Build a hybrid NLPModel</a></li><li><a class="tocitem" href="../generic/">Support multiple precision</a></li><li><a class="tocitem" href="../sparse/">Sparse Jacobian and Hessian</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li><li><a class="tocitem" href="../sparsity_pattern/">Providing sparsity pattern for sparse derivatives</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ADNLPModels.ADModelBackend"><code>ADNLPModels.ADModelBackend</code></a></li><li><a href="#ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S"><code>ADNLPModels.ADNLPModel</code></a></li><li><a href="#ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S"><code>ADNLPModels.ADNLSModel</code></a></li><li><a href="#ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}"><code>ADNLPModels.compute_hessian_sparsity</code></a></li><li><a href="#ADNLPModels.compute_jacobian_sparsity"><code>ADNLPModels.compute_jacobian_sparsity</code></a></li><li><a href="#ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}"><code>ADNLPModels.get_F</code></a></li><li><a href="#ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_adbackend</code></a></li><li><a href="#ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_c</code></a></li><li><a href="#ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}"><code>ADNLPModels.get_default_backend</code></a></li><li><a href="#ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}"><code>ADNLPModels.get_lag</code></a></li><li><a href="#ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_nln_nnzh</code></a></li><li><a href="#ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_nln_nnzj</code></a></li><li><a href="#ADNLPModels.get_residual_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_residual_nnzh</code></a></li><li><a href="#ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_residual_nnzj</code></a></li><li><a href="#ADNLPModels.get_sparsity_pattern-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, Symbol}"><code>ADNLPModels.get_sparsity_pattern</code></a></li><li><a href="#ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}"><code>ADNLPModels.set_adbackend!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.ADModelBackend" href="#ADNLPModels.ADModelBackend"><code>ADNLPModels.ADModelBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADModelBackend(gradient_backend, hprod_backend, jprod_backend, jtprod_backend, jacobian_backend, hessian_backend, ghjvprod_backend, hprod_residual_backend, jprod_residual_backend, jtprod_residual_backend, jacobian_residual_backend, hessian_residual_backend)</code></pre><p>Structure that define the different backend used to compute automatic differentiation of an <code>ADNLPModel</code>/<code>ADNLSModel</code> model. The different backend are all subtype of <code>ADBackend</code> and are respectively used for:</p><ul><li>gradient computation;</li><li>hessian-vector products;</li><li>jacobian-vector products;</li><li>transpose jacobian-vector products;</li><li>jacobian computation;</li><li>hessian computation;</li><li>directional second derivative computation, i.e. gᵀ ∇²cᵢ(x) v.</li></ul><p>The default constructors are      ADModelBackend(nvar, f, ncon = 0, c = (args...) -&gt; []; show<em>time::Bool = false, kwargs...)     ADModelNLSBackend(nvar, F!, nequ, ncon = 0, c = (args...) -&gt; []; show</em>time::Bool = false, kwargs...)</p><p>If <code>show_time</code> is set to <code>true</code>, it prints the time used to generate each backend.</p><p>The remaining <code>kwargs</code> are either the different backends as listed below or arguments passed to the backend&#39;s constructors:</p><ul><li><code>gradient_backend = ForwardDiffADGradient</code>;</li><li><code>hprod_backend = ForwardDiffADHvprod</code>;</li><li><code>jprod_backend = ForwardDiffADJprod</code>;</li><li><code>jtprod_backend = ForwardDiffADJtprod</code>;</li><li><code>jacobian_backend = SparseADJacobian</code>;</li><li><code>hessian_backend = ForwardDiffADHessian</code>;</li><li><code>ghjvprod_backend = ForwardDiffADGHjvprod</code>;</li><li><code>hprod_residual_backend = ForwardDiffADHvprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jprod_residual_backend = ForwardDiffADJprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jtprod_residual_backend = ForwardDiffADJtprod</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>jacobian_residual_backend = SparseADJacobian</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise;</li><li><code>hessian_residual_backend = ForwardDiffADHessian</code> for <code>ADNLSModel</code> and <code>EmptyADbackend</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ad.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S" href="#ADNLPModels.ADNLPModel-Union{Tuple{S}, Tuple{Any, S}} where S"><code>ADNLPModels.ADNLPModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADNLPModel(f, x0)
ADNLPModel(f, x0, lvar, uvar)
ADNLPModel(f, x0, clinrows, clincols, clinvals, lcon, ucon)
ADNLPModel(f, x0, A, lcon, ucon)
ADNLPModel(f, x0, c, lcon, ucon)
ADNLPModel(f, x0, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLPModel(f, x0, A, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, c, lcon, ucon)
ADNLPModel(model::AbstractNLPModel)</code></pre><p>ADNLPModel is an AbstractNLPModel using automatic differentiation to compute the derivatives. The problem is defined as</p><pre><code class="nohighlight hljs"> min  f(x)
s.to  lcon ≤ (  Ax  ) ≤ ucon
             ( c(x) )
      lvar ≤   x  ≤ uvar.</code></pre><p>The following keyword arguments are available to all constructors:</p><ul><li><code>minimize</code>: A boolean indicating whether this is a minimization problem (default: true)</li><li><code>name</code>: The name of the model (default: &quot;Generic&quot;)</li></ul><p>The following keyword arguments are available to the constructors for constrained problems:</p><ul><li><code>y0</code>: An inital estimate to the Lagrangian multipliers (default: zeros)</li></ul><p><code>ADNLPModel</code> uses <code>ForwardDiff</code> and <code>ReverseDiff</code> for the automatic differentiation. One can specify a new backend with the keyword arguments <code>backend::ADNLPModels.ADBackend</code>. There are three pre-coded backends:</p><ul><li>the default <code>ForwardDiffAD</code>.</li><li><code>ReverseDiffAD</code>.</li><li><code>ZygoteDiffAD</code> accessible after loading <code>Zygote.jl</code> in your environment.</li></ul><p>For an advanced usage, one can define its own backend and redefine the API as done in <a href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/src/forward.jl">ADNLPModels.jl/src/forward.jl</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
nvar = 3
ADNLPModel(f, x0) # uses the default ForwardDiffAD backend.
ADNLPModel(f, x0; backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLPModel(f, x0; backend = ADNLPModels.ZygoteAD)</code></pre><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
c(x) = [1x[1] + x[2]; x[2]]
nvar, ncon = 3, 2
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLPModel(f, x0, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ZygoteAD)</code></pre><p>For in-place constraints function, use one of the following constructors:</p><pre><code class="nohighlight hljs">ADNLPModel!(f, x0, c!, lcon, ucon)
ADNLPModel!(f, x0, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLPModel!(f, x0, A, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLPModel(f, x0, lvar, uvar, A, c!, lcon, ucon)
ADNLSModel!(model::AbstractNLSModel)</code></pre><p>where the constraint function has the signature <code>c!(output, input)</code>.</p><pre><code class="language-julia hljs">using ADNLPModels
f(x) = sum(x)
x0 = ones(3)
function c!(output, x) 
  output[1] = 1x[1] + x[2]
  output[2] = x[2]
end
nvar, ncon = 3, 2
nlp = ADNLPModel!(f, x0, c!, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/nlp.jl#L29-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S" href="#ADNLPModels.ADNLSModel-Union{Tuple{S}, Tuple{Any, S, Integer}} where S"><code>ADNLPModels.ADNLSModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADNLSModel(F, x0, nequ)
ADNLSModel(F, x0, nequ, lvar, uvar)
ADNLSModel(F, x0, nequ, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel(F, x0, nequ, A, lcon, ucon)
ADNLSModel(F, x0, nequ, c, lcon, ucon)
ADNLSModel(F, x0, nequ, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLSModel(F, x0, nequ, A, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, A, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, c, lcon, ucon)
ADNLSModel(F, x0, nequ, lvar, uvar, A, c, lcon, ucon)
ADNLSModel(model::AbstractNLSModel)</code></pre><p>ADNLSModel is an Nonlinear Least Squares model using automatic differentiation to compute the derivatives. The problem is defined as</p><pre><code class="nohighlight hljs"> min  ½‖F(x)‖²
s.to  lcon ≤ (  Ax  ) ≤ ucon
             ( c(x) )
      lvar ≤   x  ≤ uvar</code></pre><p>where <code>nequ</code> is the size of the vector <code>F(x)</code> and the linear constraints come first.</p><p>The following keyword arguments are available to all constructors:</p><ul><li><code>linequ</code>: An array of indexes of the linear equations (default: <code>Int[]</code>)</li><li><code>minimize</code>: A boolean indicating whether this is a minimization problem (default: true)</li><li><code>name</code>: The name of the model (default: &quot;Generic&quot;)</li></ul><p>The following keyword arguments are available to the constructors for constrained problems:</p><ul><li><code>y0</code>: An inital estimate to the Lagrangian multipliers (default: zeros)</li></ul><p><code>ADNLSModel</code> uses <code>ForwardDiff</code> and <code>ReverseDiff</code> for the automatic differentiation. One can specify a new backend with the keyword arguments <code>backend::ADNLPModels.ADBackend</code>. There are three pre-coded backends:</p><ul><li>the default <code>ForwardDiffAD</code>.</li><li><code>ReverseDiffAD</code>.</li><li><code>ZygoteDiffAD</code> accessible after loading <code>Zygote.jl</code> in your environment.</li></ul><p>For an advanced usage, one can define its own backend and redefine the API as done in <a href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/main/src/forward.jl">ADNLPModels.jl/src/forward.jl</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ADNLPModels
F(x) = [x[2]; x[1]]
nequ = 2
x0 = ones(3)
nvar = 3
ADNLSModel(F, x0, nequ) # uses the default ForwardDiffAD backend.
ADNLSModel(F, x0, nequ; backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLSModel(F, x0, nequ; backend = ADNLPModels.ZygoteAD)</code></pre><pre><code class="language-julia hljs">using ADNLPModels
F(x) = [x[2]; x[1]]
nequ = 2
x0 = ones(3)
c(x) = [1x[1] + x[2]; x[2]]
nvar, ncon = 3, 2
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon)) # uses the default ForwardDiffAD backend.
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ReverseDiffAD) # uses ReverseDiffAD backend.

using Zygote
ADNLSModel(F, x0, nequ, c, zeros(ncon), zeros(ncon); backend = ADNLPModels.ZygoteAD)</code></pre><p>For in-place constraints and residual function, use one of the following constructors:</p><pre><code class="nohighlight hljs">ADNLSModel!(F!, x0, nequ)
ADNLSModel!(F!, x0, nequ, lvar, uvar)
ADNLSModel!(F!, x0, nequ, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel!(F!, x0, nequ, A, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, A, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, clinrows, clincols, clinvals, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, A, c!, lcon, ucon)
ADNLSModel!(F!, x0, nequ, lvar, uvar, A, clcon, ucon)
ADNLSModel!(model::AbstractNLSModel)</code></pre><p>where the constraint function has the signature <code>c!(output, input)</code>.</p><pre><code class="language-julia hljs">using ADNLPModels
function F!(output, x)
  output[1] = x[2]
  output[2] = x[1]
end
nequ = 2
x0 = ones(3)
function c!(output, x) 
  output[1] = 1x[1] + x[2]
  output[2] = x[2]
end
nvar, ncon = 3, 2
nls = ADNLSModel!(F!, x0, nequ, c!, zeros(ncon), zeros(ncon))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/nls.jl#L33-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}" href="#ADNLPModels.compute_hessian_sparsity-NTuple{4, Any}"><code>ADNLPModels.compute_hessian_sparsity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_hessian_sparsity(f, nvar, c!, ncon; detector)</code></pre><p>Return a sparse boolean matrix that represents the adjacency matrix of the Hessian of f(x) + λᵀc(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/sparsity_pattern.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.compute_jacobian_sparsity" href="#ADNLPModels.compute_jacobian_sparsity"><code>ADNLPModels.compute_jacobian_sparsity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_jacobian_sparsity(c, x0; detector)
compute_jacobian_sparsity(c!, cx, x0; detector)</code></pre><p>Return a sparse boolean matrix that represents the adjacency matrix of the Jacobian of c(x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/sparsity_pattern.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}" href="#ADNLPModels.get_F-Tuple{ADNLPModels.AbstractADNLSModel}"><code>ADNLPModels.get_F</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_F(nls)
get_F(nls, ::ADBackend)</code></pre><p>Return the out-of-place version of <code>nls.F!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ADNLPModels.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}" href="#ADNLPModels.get_adbackend-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_adbackend</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_adbackend(nlp)</code></pre><p>Returns the value <code>adbackend</code> from nlp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ADNLPModels.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}" href="#ADNLPModels.get_c-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}}"><code>ADNLPModels.get_c</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_c(nlp)
get_c(nlp, ::ADBackend)</code></pre><p>Return the out-of-place version of <code>nlp.c!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ADNLPModels.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}" href="#ADNLPModels.get_default_backend-Tuple{Symbol, Vararg{Any}}"><code>ADNLPModels.get_default_backend</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_default_backend(meth::Symbol, backend::Symbol; kwargs...)
get_default_backend(::Val{::Symbol}, backend; kwargs...)</code></pre><p>Return a type <code>&lt;:ADBackend</code> that corresponds to the default <code>backend</code> use for the method <code>meth</code>. See <code>keys(ADNLPModels.predefined_backend)</code> for a list of possible backends.</p><p>The following keyword arguments are accepted:</p><ul><li><code>matrix_free::Bool</code>: If <code>true</code>, this returns an <code>EmptyADbackend</code> for methods that handle matrices, e.g. <code>:hessian_backend</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/predefined_backend.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}" href="#ADNLPModels.get_lag-Tuple{ADNLPModels.AbstractADNLPModel, ADNLPModels.ADBackend, Real}"><code>ADNLPModels.get_lag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_lag(nlp, b::ADBackend, obj_weight)
get_lag(nlp, b::ADBackend, obj_weight, y)</code></pre><p>Return the lagrangian function <code>ℓ(x) = obj_weight * f(x) + c(x)ᵀy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ADNLPModels.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}" href="#ADNLPModels.get_nln_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_nln_nnzh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nln_nnzh(::ADBackend, nvar)
get_nln_nnzh(b::ADModelBackend, nvar)
get_nln_nnzh(nlp::AbstractNLPModel, nvar)</code></pre><p>For a given <code>ADBackend</code> of a problem with <code>nvar</code> variables, return the number of nonzeros in the lower triangle of the Hessian. If <code>b</code> is the <code>ADModelBackend</code> then <code>b.hessian_backend</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ad_api.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}" href="#ADNLPModels.get_nln_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_nln_nnzj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nln_nnzj(::ADBackend, nvar, ncon)
get_nln_nnzj(b::ADModelBackend, nvar, ncon)
get_nln_nnzj(nlp::AbstractNLPModel, nvar, ncon)</code></pre><p>For a given <code>ADBackend</code> of a problem with <code>nvar</code> variables and <code>ncon</code> constraints, return the number of nonzeros in the Jacobian of nonlinear constraints. If <code>b</code> is the <code>ADModelBackend</code> then <code>b.jacobian_backend</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ad_api.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_residual_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}" href="#ADNLPModels.get_residual_nnzh-Tuple{ADNLPModels.ADModelBackend, Any}"><code>ADNLPModels.get_residual_nnzh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_residual_nnzh(b::ADModelBackend, nvar)
get_residual_nnzh(nls::AbstractNLSModel, nvar)</code></pre><p>Return the number of nonzeros elements in the residual Hessians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ad_api.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}" href="#ADNLPModels.get_residual_nnzj-Tuple{ADNLPModels.ADModelBackend, Any, Any}"><code>ADNLPModels.get_residual_nnzj</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_residual_nnzj(b::ADModelBackend, nvar, nequ)
get_residual_nnzj(nls::AbstractNLSModel, nvar, nequ)</code></pre><p>Return the number of nonzeros elements in the residual Jacobians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ad_api.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.get_sparsity_pattern-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, Symbol}" href="#ADNLPModels.get_sparsity_pattern-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, Symbol}"><code>ADNLPModels.get_sparsity_pattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S = get_sparsity_pattern(model::ADModel, derivative::Symbol)</code></pre><p>Retrieve the sparsity pattern of a Jacobian or Hessian from an <code>ADModel</code>. For the Hessian, only the lower triangular part of its sparsity pattern is returned. The user can reconstruct the upper triangular part by exploiting symmetry.</p><p>To compute the sparsity pattern, the model must use a sparse backend. Supported backends include <code>SparseADJacobian</code>, <code>SparseADHessian</code>, and <code>SparseReverseADHessian</code>.</p><p><strong>Input arguments</strong></p><ul><li><code>model</code>: An automatic differentiation model (either <code>AbstractADNLPModel</code> or <code>AbstractADNLSModel</code>).</li><li><code>derivative</code>: The type of derivative for which the sparsity pattern is needed. The supported values are <code>:jacobian</code>, <code>:hessian</code>, <code>:jacobian_residual</code> and <code>:hessian_residual</code>.</li></ul><p><strong>Output argument</strong></p><ul><li><code>S</code>: A sparse matrix of type <code>SparseMatrixCSC{Bool,Int}</code> indicating the sparsity pattern of the requested derivative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/sparsity_pattern.jl#L58-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}" href="#ADNLPModels.set_adbackend!-Tuple{Union{ADNLPModels.AbstractADNLPModel{T, S}, ADNLPModels.AbstractADNLSModel{T, S}} where {T, S}, ADNLPModels.ADModelBackend}"><code>ADNLPModels.set_adbackend!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_adbackend!(nlp, new_adbackend)
set_adbackend!(nlp; kwargs...)</code></pre><p>Replace the current <code>adbackend</code> value of nlp by <code>new_adbackend</code> or instantiate a new one with <code>kwargs</code>, see <code>ADModelBackend</code>. By default, the setter with kwargs will reuse existing backends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/ADNLPModels.jl/blob/426c8b39925ee2892a71fa2f2fe15f46865aa66d/src/ADNLPModels.jl#L246-L252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sparsity_pattern/">« Providing sparsity pattern for sparse derivatives</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 4 June 2025 22:54">Wednesday 4 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
